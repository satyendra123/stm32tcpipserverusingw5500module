/* w5500_tcp_server.c
   Cleaned & corrected version of user's code.
   Adapt GPIO/SPI/UART init functions as per your project.
*/

#include "wizchip_conf.h"
#include "socket.h"
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdarg.h>
#include "stm32f1xx_hal.h"

/* HAL handles - must be provided by your project */
extern SPI_HandleTypeDef hspi1;
extern UART_HandleTypeDef huart2;

/* Replace with actual functions generated by CubeMX if different */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI1_Init(void);
static void MX_USART2_UART_Init(void);

/* Network config */
wiz_NetInfo net_info = {
    .mac = {0xDE,0xAD,0xBE,0xEF,0xFE,0xED},
    .ip  = {192,168,2,99},
    .sn  = {255,255,255,0},
    .gw  = {192,168,2,1},
    .dns = {8,8,8,8},
    .dhcp = NETINFO_STATIC
};

/* Application config */
#define TCP_PORT    5000
#define RX_BUFFER_SIZE 256

/* LED pin (change if needed) */
#define LED_GPIO_PORT GPIOC
#define LED_PIN       GPIO_PIN_13

typedef struct {
    uint8_t rxBuffer[RX_BUFFER_SIZE];
    uint8_t txBuffer[RX_BUFFER_SIZE];
    uint8_t rxByte;
    uint16_t rxFillIndex;
    uint16_t txFillIndex;
    uint16_t rxReadIndex;
    uint16_t txReadIndex;
    uint32_t lastByteTimestamp;
} uartStream;

static uartStream uart2Stream; /* single instance for UART2 streams */

/* Simple safe printf into uart2Stream tx buffer and transmit over HAL UART */
void myprintf(const char * format, ...)
{
    char buffer[128];
    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    size_t len = strlen(buffer);
    for (size_t i = 0; i < len; ++i) {
        uart2Stream.txBuffer[uart2Stream.txFillIndex++] = (uint8_t)buffer[i];
        if (uart2Stream.txFillIndex >= RX_BUFFER_SIZE) uart2Stream.txFillIndex = 0;
    }

    /* transmit all pending bytes (blocking) */
    while (uart2Stream.txReadIndex != uart2Stream.txFillIndex) {
        uint8_t b = uart2Stream.txBuffer[uart2Stream.txReadIndex++];
        if (uart2Stream.txReadIndex >= RX_BUFFER_SIZE) uart2Stream.txReadIndex = 0;
        HAL_UART_Transmit(&huart2, &b, 1, HAL_MAX_DELAY);
    }
}

/* WIZCHIP CS control and SPI byte/burst callbacks */
static void wizchipSelect(void)
{
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET); /* CS low */
}
static void wizchipUnselect(void)
{
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);   /* CS high */
}

/* SPI single-byte read/write (as required by WIZCHIP lib) */
static uint8_t wizchipSPI_ReadByte(void)
{
    uint8_t rx = 0xFF;
    HAL_SPI_Receive(&hspi1, &rx, 1, HAL_MAX_DELAY);
    return rx;
}
static void wizchipSPI_WriteByte(uint8_t b)
{
    HAL_SPI_Transmit(&hspi1, &b, 1, HAL_MAX_DELAY);
}

/* burst operations */
static void wizchipReadBurst(uint8_t *buff, uint16_t len)
{
    HAL_SPI_Receive(&hspi1, buff, len, HAL_MAX_DELAY);
}
static void wizchipWriteBurst(uint8_t *buff, uint16_t len)
{
    HAL_SPI_Transmit(&hspi1, buff, len, HAL_MAX_DELAY);
}

static void wizChipInit(void)
{
    /* register callbacks */
    reg_wizchip_cs_cbfunc(wizchipSelect, wizchipUnselect);
    reg_wizchip_spi_cbfunc(wizchipSPI_ReadByte, wizchipSPI_WriteByte);
    reg_wizchip_spiburst_cbfunc(wizchipReadBurst, wizchipWriteBurst);

    myprintf("wizchip callbacks registered\r\n");

    /* setup socket buffer sizes (2KB each socket here) -> array length 8 */
    uint8_t tx_rx_buff_sizes[8] = {2,2,2,2,2,2,2,2}; /* 2KB per socket */
    if (wizchip_init(tx_rx_buff_sizes, tx_rx_buff_sizes) != 0) {
        myprintf("wizchip_init completed\r\n");
    } else {
        myprintf("wizchip_init failed or returned unexpected value\r\n");
    }
}

/* return 1 if link is up, 0 if down */
static uint8_t checkLinkStatus(void)
{
    uint8_t phycfgr = getPHYCFGR();
    if (phycfgr & PHYCFGR_LINK_ON) {
        return 1;
    } else {
        return 0;
    }
}

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_SPI1_Init();
    MX_USART2_UART_Init();

    /* init uart2Stream indices */
    memset(&uart2Stream, 0, sizeof(uart2Stream));

    /* init WIZchip and network */
    wizChipInit();
    wizchip_setnetinfo(&net_info);

    /* wait until physical link is up */
    while (checkLinkStatus() == 0) {
        myprintf("waiting for link to be established... \r\n");
        HAL_Delay(1000);
    }
    myprintf("Link established, initializing w5500... \r\n");

    /* create socket on socket 0 */
    int8_t tcp_sock = socket(0, Sn_MR_TCP, TCP_PORT, 0);
    if (tcp_sock != 0) {
        myprintf("failed to create tcp socket (expected socket 0). returned=%d\r\n", tcp_sock);
    } else {
        int8_t ret = listen(tcp_sock);
        if (ret != SOCK_OK) {
            myprintf("Failed to listen on tcp socket: %d\r\n", ret);
            close(tcp_sock);
        } else {
            myprintf("TCP server listening on port %d\r\n", TCP_PORT);
        }
    }

    uint8_t connectionStatus = 0;

    /* main loop */
    while (1)
    {
        /* monitor link */
        if (checkLinkStatus() == 0)
        {
            if (connectionStatus != 0) {
                myprintf("Ethernet link lost! closing tcp connection.\r\n");
                connectionStatus = 0;
                disconnect(0);
            }
            while (checkLinkStatus() == 0) {
                myprintf("waiting for link to be established...\r\n");
                HAL_Delay(1000);
            }
            myprintf("Ethernet link re-established\r\n");

            /* recreate socket and listen again */
            tcp_sock = socket(0, Sn_MR_TCP, TCP_PORT, 0);
            if (tcp_sock == 0) {
                int8_t ret = listen(tcp_sock);
                if (ret == SOCK_OK) {
                    myprintf("TCP server re-listening on port %d\r\n", TCP_PORT);
                } else {
                    myprintf("listen() after re-link failed: %d\r\n", ret);
                }
            } else {
                myprintf("socket() after re-link returned %d\r\n", tcp_sock);
            }
            continue;
        }

        /* check socket status */
        uint8_t sock_status = getSnSR(0);

        if (sock_status == SOCK_ESTABLISHED)
        {
            if (connectionStatus == 0) {
                connectionStatus = 1;
                myprintf("TCP client connected\r\n");
                const char msgOnConnection[] = "TCP server: connection established\r\n";
                int32_t sent_len = send(0, (uint8_t*)msgOnConnection, strlen(msgOnConnection));
                if (sent_len != (int32_t)strlen(msgOnConnection)) {
                    myprintf("Failed to send connection message back to client\r\n");
                }
            }

            if (connectionStatus == 1)
            {
                uint8_t tcp_rx_buf[64] = {0};
                uint8_t tcp_tx_buf[64] = {0};
                int32_t recv_len = recv(0, tcp_rx_buf, sizeof(tcp_rx_buf));
                if (recv_len > 0) {
                    /* ensure string termination */
                    if (recv_len < (int32_t)sizeof(tcp_rx_buf)) {
                        tcp_rx_buf[recv_len] = 0;
                    } else {
                        tcp_rx_buf[sizeof(tcp_rx_buf)-1] = 0;
                    }

                    myprintf("Received %ld bytes from TCP client\r\n", recv_len);
                    myprintf("data received= %s\r\n", tcp_rx_buf);

                    if (strcmp((char*)tcp_rx_buf, "ON") == 0) {
                        HAL_GPIO_WritePin(LED_GPIO_PORT, LED_PIN, GPIO_PIN_RESET); /* LED ON (active low on many boards) */
                        strcpy((char*)tcp_tx_buf, "LED IS ON\r\n");
                    }
                    else if (strcmp((char*)tcp_rx_buf, "OFF") == 0) {
                        HAL_GPIO_WritePin(LED_GPIO_PORT, LED_PIN, GPIO_PIN_SET); /* LED OFF */
                        strcpy((char*)tcp_tx_buf, "LED IS OFF\r\n");
                    } else {
                        strcpy((char*)tcp_tx_buf, "UNKNOWN COMMAND\r\n");
                    }

                    int32_t sent_len = send(0, tcp_tx_buf, strlen((char*)tcp_tx_buf));
                    if (sent_len != (int32_t)strlen((char*)tcp_tx_buf)) {
                        myprintf("Failed to send data back to client\r\n");
                    }
                }
            }
        }

        if (sock_status == SOCK_CLOSE_WAIT) {
            connectionStatus = 0;
            myprintf("TCP client disconnected (CLOSE_WAIT)\r\n");
            disconnect(0);
            while (checkLinkStatus() == 0) {
                myprintf("waiting for link to be established...\r\n");
                HAL_Delay(1000);
            }
        }

        if (sock_status == SOCK_CLOSED) {
            connectionStatus = 0;
            tcp_sock = socket(0, Sn_MR_TCP, TCP_PORT, 0);
            if (tcp_sock == 0) {
                int8_t ret = listen(tcp_sock);
                if (ret == SOCK_OK) {
                    myprintf("TCP server re-listening on port %d\r\n", TCP_PORT);
                } else {
                    myprintf("listen() returned %d\r\n", ret);
                }
            } else {
                myprintf("socket() returned %d in SOCK_CLOSED branch\r\n", tcp_sock);
            }
        }

        HAL_Delay(10); /* small delay to avoid busy-waiting */
    }
}
